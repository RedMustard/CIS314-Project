{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf160
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\sl480\slmult1\pardirnatural

\f0\fs24 \cf0 In order to implement pipelining on our virtual processor we decided to use a while loop and a clockCounter. After each iteration of the loop we will increment the clockCounter and this will represent one cycle. During the execution of the loop there will be a total of five instructions being worked on, each at a different stage in processing. We have a currentInstructions[ ] array which will hold the index(in the main instruction memory) of the instructions currently being worked on. There are several corresponding arrays,called helper arrays, to assist in implementing this method. All arguments, registers, and commands are now all held in arrays, as well as a helper array to track which stage each instruction is in. All of these arrays are linked together with one key value that changes throughout each iteration in the loop, this value is called num. Num represents the index of the current instruction being worked on, along with its corresponding helper arrays(i.e. if num is 0, then the instruction being worked on is in currentInstruction[0], and all corresponding data are held in index 0 of the helper arrays). In this way we can track the data of the proper instruction when its current stage is being executed. The value for num is determined by the equation \'93total % 5\'94,where \'91total\'92 is the total number of stages (not instructions) that have been executed(this includes NO OPs). Using mod 5 on the total will give us a oscillating value between 0 and 4(which is the remainder given by modding the total), in this way we can index through the currentInstruction array and its helper arrays with ease. To track the progress of an instruction we use the helper array nextStage[ ] which contains a value 0 through 4 which will correspond to the stage number the particular instruction is one. After executing a given stage the value held in nextStage[ ] is incremented by 1(unless the current instruction is being stalled). Once an instructions next stage value is 5 it is complete and thus ready to be  replaced with the next instruction from instructionMemory[ ]. Swapping of a completed instruction for a new instruction is done in the fetch() call, it will remove the old instruction and place in a new one. In the event that registers called in a newer instruction have not yet been written back to, we must insert bubbles (or NO OPs) to stall the instructions until the registers have their proper values. To account for this we compare the arguments in the current instruction to the destinations(held  of the previous instructions that are still in the pipeline. If any of them are equal, we send a NO OP. This is done by placing a bubble into the currentInstruction[ ] array. We simply put a \'91-1\'92 in place of an instruction index in the currentInstruction[ ]. When and index holding this string  is called upon into a function it has a special case that simply makes the function return nothing. The bubbles will enter each necessary stage and then be popped out and replaced like all the other, normal instructions.  The loop will end when all instructions have been executed and the program will end. \
During our testing, we have had several bugs. Most of these bugs revolved around formatting in the files we were using for testing. However, there are more bugs revolving around our logic that are close to being ironed out.}